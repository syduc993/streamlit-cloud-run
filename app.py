import streamlit as st
from google.oauth2 import service_account
from google.cloud import bigquery
import pandas as pd
import os
import math
import requests
from typing import Dict, List, Optional
from math import ceil

# C·∫•u h√¨nh trang
st.set_page_config(
    page_title="BigQuery to Larkbase",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# CSS ƒë·ªÉ ·∫©n sidebar ho√†n to√†n
st.markdown("""
<style>
    [data-testid="stSidebar"] {display: none;}
    [data-testid="collapsedControl"] {display: none;}
    .main .block-container {
        padding-top: 2rem;
        padding-bottom: 2rem;
        max-width: 100%;
    }
    .stTextArea textarea {
        height: 120px;
    }
    .metric-container {
        background-color: #f0f2f6;
        padding: 0.5rem;
        border-radius: 0.5rem;
        text-align: center;
        margin: 0.25rem 0;
    }
    .larkbase-section {
        background-color: #f8f9fa;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #28a745;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

# Larkbase Configuration
class LarkbaseConfig:
    def __init__(self, app_id=None, app_secret=None, api_endpoint=None):
        self.app_id = app_id or 'cli_a7fab27260385010'
        self.app_secret = app_secret or 'Zg4MVcFfiOu0g09voTcpfd4WGDpA0Ly5'
        self.api_endpoint = api_endpoint or 'https://open.larksuite.com/open-apis'
    
    def to_dict(self) -> Dict:
        return {
            'app_id': self.app_id,
            'app_secret': self.app_secret,
            'api_endpoint': self.api_endpoint
        }

class LarkbaseAuthenticator:
    def __init__(self, config: LarkbaseConfig):
        self.config = config
    
    def authenticate(self) -> Optional[str]:
        """X√°c th·ª±c v·ªõi API Larkbase ƒë·ªÉ l·∫•y access token"""
        try:
            url = f"{self.config.api_endpoint}/auth/v3/tenant_access_token/internal"
            response = requests.post(url, json={
                'app_id': self.config.app_id, 
                'app_secret': self.config.app_secret
            })
            response.raise_for_status()
            data = response.json()
            
            if data.get('code') == 0:
                return data.get('tenant_access_token')
            else:
                st.error(f"L·ªói API Larkbase: {data.get('msg', 'Kh√¥ng x√°c ƒë·ªãnh')}")
                return None
        except Exception as e:
            st.error(f"L·ªói x√°c th·ª±c Larkbase: {str(e)}")
            return None

class LarkbaseRecordManager:
    def __init__(self, access_token: str, config: LarkbaseConfig):
        self.access_token = access_token
        self.config = config
    
    def get_all_records(self, app_token: str, table_id: str) -> List[str]:
        """L·∫•y t·∫•t c·∫£ record IDs t·ª´ b·∫£ng"""
        url = f"{self.config.api_endpoint}/bitable/v1/apps/{app_token}/tables/{table_id}/records"
        headers = {
            "Authorization": f"Bearer {self.access_token}",
            "Content-Type": "application/json"
        }
        
        all_record_ids = []
        page_token = None
        
        while True:
            params = {"page_size": 500}
            if page_token:
                params["page_token"] = page_token
            
            response = requests.get(url, headers=headers, params=params)
            
            try:
                data = response.json()
                if data.get('code') == 0:
                    records = data.get('data', {}).get('items', [])
                    record_ids = [record.get('record_id') for record in records]
                    all_record_ids.extend(record_ids)
                    
                    # Ki·ªÉm tra c√≥ trang ti·∫øp theo kh√¥ng
                    page_token = data.get('data', {}).get('page_token')
                    if not page_token:
                        break
                else:
                    st.error(f"L·ªói l·∫•y records: {data.get('msg')}")
                    break
            except Exception as e:
                st.error(f"L·ªói parse response: {str(e)}")
                break
        
        return all_record_ids
    
    def batch_delete_records(self, records: List[str], app_token: str, table_id: str) -> Dict:
        """X√≥a nhi·ªÅu record kh·ªèi b·∫£ng tr√™n Lark Bitable"""
        if not records:
            return {"status": "no_records", "message": "Kh√¥ng c√≥ record n√†o ƒë·ªÉ x√≥a."}

        url = f"{self.config.api_endpoint}/bitable/v1/apps/{app_token}/tables/{table_id}/records/batch_delete"
        headers = {
            "Authorization": f"Bearer {self.access_token}",
            "Content-Type": "application/json"
        }

        batch_size = 500
        total_records = len(records)
        total_batches = ceil(total_records / batch_size)
        results = []
        errors = []

        progress_bar = st.progress(0)
        status_text = st.empty()

        for i in range(total_batches):
            batch = records[i * batch_size:(i + 1) * batch_size]
            data = {"records": batch}
            response = requests.post(url, headers=headers, json=data)
            
            try:
                result = response.json()
                results.append(result)
                if response.status_code != 200 or result.get("code", 0) != 0:
                    errors.append({
                        "batch_index": i,
                        "status_code": response.status_code,
                        "response": result
                    })
                    status_text.text(f"Batch {i+1}/{total_batches}: L·ªói x√≥a {len(batch)} b·∫£n ghi")
                else:
                    status_text.text(f"Batch {i+1}/{total_batches}: X√≥a th√†nh c√¥ng {len(batch)} b·∫£n ghi")
            except Exception as e:
                errors.append({
                    "batch_index": i,
                    "status_code": response.status_code,
                    "exception": str(e)
                })
                status_text.text(f"Batch {i+1}/{total_batches}: L·ªói x√≥a")
            
            progress_bar.progress((i + 1) / total_batches)

        summary = {
            "total_batches": total_batches,
            "total_records": total_records,
            "success_batches": total_batches - len(errors),
            "error_batches": len(errors),
            "results": results,
            "errors": errors
        }

        return summary
    
    def batch_create_records(self, records: List[Dict], app_token: str, table_id: str, batch_size: int = 500) -> List[Dict]:
        """T·∫°o nhi·ªÅu record m·ªõi trong b·∫£ng tr√™n Lark Bitable"""
        if not records:
            return [{"status": "no_records", "message": "Kh√¥ng c√≥ record n√†o ƒë·ªÉ t·∫°o."}]

        url = f"{self.config.api_endpoint}/bitable/v1/apps/{app_token}/tables/{table_id}/records/batch_create"
        headers = {
            "Authorization": f"Bearer {self.access_token}",
            "Content-Type": "application/json"
        }

        total_records = len(records)
        total_batches = ceil(total_records / batch_size)
        results = []

        progress_bar = st.progress(0)
        status_text = st.empty()

        for i in range(0, total_batches):
            start_idx = i * batch_size
            end_idx = min((i + 1) * batch_size, total_records)
            batch = records[start_idx:end_idx]
            
            # Chu·∫©n b·ªã d·ªØ li·ªáu cho API Larkbase
            formatted_batch = []
            for record in batch:
                formatted_record = {"fields": {}}
                for key, value in record.items():
                    # Chuy·ªÉn ƒë·ªïi gi√° tr·ªã th√†nh format ph√π h·ª£p v·ªõi Larkbase
                    if pd.isna(value):
                        formatted_record["fields"][key] = ""
                    elif isinstance(value, (int, float)):
                        formatted_record["fields"][key] = value
                    else:
                        formatted_record["fields"][key] = str(value)
                formatted_batch.append(formatted_record)
            
            data = {"records": formatted_batch}
            response = requests.post(url, headers=headers, json=data)
            
            try:
                res_json = response.json()
                if res_json.get('code') == 0:
                    result = {
                        "status": "success", 
                        "batch": i+1, 
                        "created_count": len(res_json['data']['records'])
                    }
                    status_text.text(f"Batch {i+1}/{total_batches}: T·∫°o th√†nh c√¥ng {len(batch)} b·∫£n ghi")
                else:
                    result = {
                        "status": "error", 
                        "batch": i+1, 
                        "msg": res_json.get('msg'), 
                        "code": res_json.get('code')
                    }
                    status_text.text(f"Batch {i+1}/{total_batches}: L·ªói - {res_json.get('msg')}")
            except Exception as e:
                result = {
                    "status": "error", 
                    "batch": i+1, 
                    "status_code": response.status_code, 
                    "exception": str(e)
                }
                status_text.text(f"Batch {i+1}/{total_batches}: L·ªói - {str(e)}")
            
            results.append(result)
            progress_bar.progress((i + 1) / total_batches)

        return results

# BigQuery functions (gi·ªØ nguy√™n nh∆∞ c≈©)
@st.cache_resource
def init_bigquery_client():
    """Kh·ªüi t·∫°o BigQuery client"""
    try:
        if os.getenv('K_SERVICE'):
            from google.auth import default
            credentials, project = default()
            return bigquery.Client(credentials=credentials, project=project)
        else:
            credentials = service_account.Credentials.from_service_account_info(
                st.secrets["gcp_service_account"]
            )
            return bigquery.Client(credentials=credentials)
    except Exception as e:
        st.error(f"‚ùå L·ªói k·∫øt n·ªëi BigQuery: {e}")
        return None

@st.cache_data(ttl=300)
def run_bigquery_query(query, limit=1000):
    """Th·ª±c thi query v√† tr·∫£ v·ªÅ k·∫øt qu·∫£ d·∫°ng DataFrame"""
    client = init_bigquery_client()
    if client is None:
        return None
    
    try:
        query_upper = query.upper().strip()
        if not 'LIMIT' in query_upper:
            query = f"{query.rstrip(';')} LIMIT {limit}"
        
        job_config = bigquery.QueryJobConfig(
            maximum_bytes_billed=100 * 1024 * 1024,  # 100MB limit
            use_query_cache=True
        )
        
        query_job = client.query(query, job_config=job_config)
        df = query_job.to_dataframe()
        return df
    except Exception as e:
        st.error(f"‚ùå L·ªói th·ª±c thi query: {e}")
        return None

def validate_query(query):
    """Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa SQL query"""
    dangerous_keywords = ['DELETE', 'DROP', 'TRUNCATE', 'INSERT', 'UPDATE', 'ALTER', 'CREATE']
    query_upper = query.upper()
    
    for keyword in dangerous_keywords:
        if keyword in query_upper:
            return False, f"Query ch·ª©a t·ª´ kh√≥a nguy hi·ªÉm: {keyword}"
    
    if not query.strip().upper().startswith('SELECT'):
        return False, "Query ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng SELECT"
    
    return True, "Query h·ª£p l·ªá"

def paginate_dataframe(df, page_size=10):
    """Chia DataFrame th√†nh c√°c trang"""
    if 'current_page' not in st.session_state:
        st.session_state.current_page = 0
    
    total_pages = math.ceil(len(df) / page_size)
    
    if total_pages > 1:
        col1, col2, col3, col4, col5 = st.columns([1, 1, 2, 1, 1])
        
        with col1:
            if st.button("‚èÆÔ∏è ƒê·∫ßu", disabled=st.session_state.current_page == 0):
                st.session_state.current_page = 0
                st.rerun()
        
        with col2:
            if st.button("‚óÄÔ∏è Tr∆∞·ªõc", disabled=st.session_state.current_page == 0):
                st.session_state.current_page -= 1
                st.rerun()
        
        with col3:
            st.markdown(f"<div class='metric-container'>Trang {st.session_state.current_page + 1} / {total_pages}</div>", 
                       unsafe_allow_html=True)
        
        with col4:
            if st.button("‚ñ∂Ô∏è Sau", disabled=st.session_state.current_page >= total_pages - 1):
                st.session_state.current_page += 1
                st.rerun()
        
        with col5:
            if st.button("‚è≠Ô∏è Cu·ªëi", disabled=st.session_state.current_page >= total_pages - 1):
                st.session_state.current_page = total_pages - 1
                st.rerun()
    
    start_idx = st.session_state.current_page * page_size
    end_idx = start_idx + page_size
    return df.iloc[start_idx:end_idx]

def main():
    st.markdown("### üìä BigQuery to Larkbase")
    
    # Ki·ªÉm tra k·∫øt n·ªëi BigQuery
    client = init_bigquery_client()
    if client is None:
        st.error("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn BigQuery")
        st.stop()
    
    # Query section (gi·ªØ nguy√™n nh∆∞ c≈©)
    col1, col2 = st.columns([4, 1])
    
    with col1:
        query = st.text_area(
            "SQL Query:",
            placeholder="SELECT * FROM `project.dataset.table` WHERE condition = 'value'",
            help="Ch·ªâ h·ªó tr·ª£ SELECT queries"
        )
    
    with col2:
        st.markdown("<br>", unsafe_allow_html=True)
        execute_button = st.button("üöÄ Th·ª±c thi", type="primary", use_container_width=True)
        
        if query.strip():
            is_valid, message = validate_query(query)
            if is_valid:
                st.success("‚úÖ H·ª£p l·ªá")
            else:
                st.error("‚ùå Kh√¥ng h·ª£p l·ªá")
    
    # Execute query (gi·ªØ nguy√™n nh∆∞ c≈©)
    if execute_button and query.strip():
        is_valid, message = validate_query(query)
        if not is_valid:
            st.error(f"‚ùå {message}")
            return
        
        with st.spinner("üîÑ ƒêang truy v·∫•n..."):
            df = run_bigquery_query(query)
            
            if df is not None and not df.empty:
                st.session_state.current_page = 0
                st.session_state.query_result = df
                
                # Metrics
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("üìä D√≤ng", f"{len(df):,}")
                with col2:
                    st.metric("üìã C·ªôt", len(df.columns))
                with col3:
                    memory_mb = df.memory_usage(deep=True).sum() / 1024**2
                    st.metric("üíæ MB", f"{memory_mb:.1f}")
                with col4:
                    st.metric("üìÑ Trang", math.ceil(len(df) / 10))
                
                # Data display
                st.markdown("**üìã K·∫øt qu·∫£:**")
                page_data = paginate_dataframe(df, page_size=10)
                st.dataframe(page_data, use_container_width=True, height=350)
                
                # Download options
                col1, col2 = st.columns(2)
                with col1:
                    csv = df.to_csv(index=False)
                    st.download_button(
                        "üì• CSV",
                        csv,
                        f"data_{pd.Timestamp.now().strftime('%H%M%S')}.csv",
                        "text/csv",
                        use_container_width=True
                    )
                with col2:
                    json_data = df.to_json(orient='records', indent=2)
                    st.download_button(
                        "üì• JSON", 
                        json_data,
                        f"data_{pd.Timestamp.now().strftime('%H%M%S')}.json",
                        "application/json",
                        use_container_width=True
                    )
                
            elif df is not None:
                st.warning("‚ö†Ô∏è Query kh√¥ng tr·∫£ v·ªÅ d·ªØ li·ªáu")
            else:
                st.error("‚ùå L·ªói th·ª±c thi query")
    
    # Larkbase section v·ªõi t√πy ch·ªçn x√≥a d·ªØ li·ªáu c≈©
    if 'query_result' in st.session_state and not st.session_state.query_result.empty:
        st.markdown('<div class="larkbase-section">', unsafe_allow_html=True)
        st.markdown("### üìù Ghi d·ªØ li·ªáu v√†o Larkbase")
        
        col1, col2 = st.columns(2)
        with col1:
            app_token = st.text_input(
                "App Token:",
                placeholder="bascnCMII2eTqzxI8qI5lc...",
                help="App Token c·ªßa Larkbase"
            )
        with col2:
            table_id = st.text_input(
                "Table ID:",
                placeholder="tblxxx...",
                help="ID c·ªßa b·∫£ng trong Larkbase"
            )
        
        # T√πy ch·ªçn x√≥a d·ªØ li·ªáu c≈©
        clear_old_data = st.checkbox(
            "üóëÔ∏è X√≥a t·∫•t c·∫£ d·ªØ li·ªáu c≈© tr∆∞·ªõc khi ghi m·ªõi",
            value=True,
            help="N·∫øu ch·ªçn, s·∫Ω x√≥a to√†n b·ªô d·ªØ li·ªáu hi·ªán c√≥ trong b·∫£ng tr∆∞·ªõc khi ghi d·ªØ li·ªáu m·ªõi"
        )
        
        if st.button("üì§ Ghi v√†o Larkbase", type="secondary", use_container_width=True):
            if not app_token or not table_id:
                st.error("‚ùå Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß App Token v√† Table ID")
                return
            
            # Kh·ªüi t·∫°o Larkbase
            config = LarkbaseConfig()
            authenticator = LarkbaseAuthenticator(config)
            
            with st.spinner("üîê ƒêang x√°c th·ª±c Larkbase..."):
                access_token = authenticator.authenticate()
            
            if access_token:
                st.success("‚úÖ X√°c th·ª±c Larkbase th√†nh c√¥ng")
                record_manager = LarkbaseRecordManager(access_token, config)
                
                # X√≥a d·ªØ li·ªáu c≈© n·∫øu ƒë∆∞·ª£c ch·ªçn
                if clear_old_data:
                    with st.spinner("üóëÔ∏è ƒêang l·∫•y danh s√°ch records c≈©..."):
                        old_record_ids = record_manager.get_all_records(app_token, table_id)
                    
                    if old_record_ids:
                        st.info(f"üìã T√¨m th·∫•y {len(old_record_ids)} b·∫£n ghi c≈©")
                        with st.spinner("üóëÔ∏è ƒêang x√≥a d·ªØ li·ªáu c≈©..."):
                            delete_result = record_manager.batch_delete_records(old_record_ids, app_token, table_id)
                        
                        if delete_result.get("error_batches", 0) == 0:
                            st.success(f"‚úÖ ƒê√£ x√≥a th√†nh c√¥ng {len(old_record_ids)} b·∫£n ghi c≈©")
                        else:
                            st.warning(f"‚ö†Ô∏è X√≥a ho√†n t·∫•t v·ªõi {delete_result.get('error_batches', 0)} l·ªói")
                    else:
                        st.info("üìã Kh√¥ng c√≥ d·ªØ li·ªáu c≈© ƒë·ªÉ x√≥a")
                
                # Ghi d·ªØ li·ªáu m·ªõi
                records = st.session_state.query_result.to_dict('records')
                
                with st.spinner("üìù ƒêang ghi d·ªØ li·ªáu m·ªõi v√†o Larkbase..."):
                    results = record_manager.batch_create_records(records, app_token, table_id)
                
                # Hi·ªÉn th·ªã k·∫øt qu·∫£
                success_count = sum(1 for r in results if r.get("status") == "success")
                error_count = len(results) - success_count
                
                if error_count == 0:
                    st.success(f"‚úÖ ƒê√£ ghi th√†nh c√¥ng {len(records)} b·∫£n ghi v√†o Larkbase!")
                else:
                    st.warning(f"‚ö†Ô∏è Ghi ho√†n t·∫•t: {success_count} th√†nh c√¥ng, {error_count} l·ªói")
                    
                    # Hi·ªÉn th·ªã chi ti·∫øt l·ªói
                    errors = [r for r in results if r.get("status") == "error"]
                    if errors:
                        with st.expander("Chi ti·∫øt l·ªói"):
                            for error in errors:
                                st.error(f"Batch {error.get('batch')}: {error.get('msg', error.get('exception'))}")
            else:
                st.error("‚ùå Kh√¥ng th·ªÉ x√°c th·ª±c v·ªõi Larkbase")
        
        st.markdown('</div>', unsafe_allow_html=True)

if __name__ == "__main__":
    main()